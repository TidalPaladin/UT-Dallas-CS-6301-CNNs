% ---------
%  Compile with "pdflatex hw1".
% --------
%!TEX TS-program = pdflatex
%!TEX encoding = UTF-8 Unicode

% Template borrowed from Jeff Erickson.

\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}		% Allow some non-ASCII Unicode in source
\usepackage{jeffe, handout,graphicx}
\usepackage{forest}
\usepackage{mathtools}
\usepackage{tikz, ifthen, etoolbox}
\usepackage{float}
\usetikzlibrary{positioning}
\newcommand{\pd}{\partial}
\newcommand{\bs}{\boldsymbol}
\newcommand{\ifstringequal}[4]{%
  \ifnum\pdfstrcmp{#1}{#2}=0
  #3%
  \else
  #4%
  \fi
}


% =========================================================
%   Define common stuff for solution headers
% =========================================================
\Class{CS 6301.503}
\Semester{Spring 2019}
\Authors{1}
\AuthorOne{Scott C. Waggener}{scw180000}
%\Section{}

% =========================================================
\begin{document}
\HomeworkHeader{5 (Algorithms)}{1}% homework number, problem number
% ---------------------------------------------------------
Read: Algorithms
\noindent
\begin{solution}
	Complete
\end{solution}

% =========================================================
\HomeworkHeader{5 (Algorithms)}{2}% homework number, problem number
% ---------------------------------------------------------
\begin{solution}
	$6n+2$ comparisons
\end{solution}

\tikzset{%
	grid/.style={
		draw,
		step=1.0,
		black,
		thin
	},
	pool/.style={
		fill=red,
		fill opacity=0.5
	},
	edge/.style={
		->,
		draw,
		thick
	},
	bound/.style={
		edge,
		<->
	}
}

\begin{proof}
	First we can find $M_c$, the number of pools to be computed for this
	example with trivial row space.

	\begin{align}
		L_c &= 2n+1 & F_c &=3 & S_c &= 2
	\end{align}

	so

	\begin{align}
		M_c &= \left\lfloor\frac{L_c - F_c}{S_c}\right\rfloor +1\\
		&= \left\lfloor\frac{2n+1 - 3}{2}\right\rfloor +1 \\
		&= \left\lfloor\frac{2n-2}{2}\right\rfloor +1 \\
		&= \left\lfloor n-1\right\rfloor +1 \\
		M_c &= n
	\end{align}

	Now that we know $M_c$ we need a way of determining how many comparisons
	are needed to compute each $M_c$. Our picture of the max pooling operation
	across an input feature map for the case

	\begin{align}
		2n+1 &= 21 & n &=10 & F_r &= F_c =3 &S_c &=2
	\end{align}

	\noindent
	looks like

	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[scale=0.5, thick]
			\draw[grid] (5,-5) grid (15,-6);
			\newtoggle{colortoggle}
			\foreach \l [count=\i] in {0, ..., 9} {
				\iftoggle{colortoggle}{
					\def \loopcolor {blue}
				}{
					\def \loopcolor {red}
				}
				\global\settoggle{colortoggle}{\iftoggle{colortoggle}{false}{true}}
				\pgfmathsetmacro{\j}{2 * \l}
				\draw[grid, pool, color=\loopcolor] (\j, 0) grid (\j+3, 3);
				\draw[bound, color=\loopcolor] (\j, 0) -- (\j+3, 3);
				\draw[bound, color=\loopcolor] (\j, 3) -- (\j+3, 0);
				\draw[edge, color=\loopcolor] (\j+1.5, 1.5) -- (\i+4.5, -5);
				\global\let\j=\j
			}
		\end{tikzpicture}
		\caption{$F_r = F_c = 3$, $2n+1=21$, $M_c=10$}
	\end{figure}

	If we implemented a naive comparison strategy, we could compare each item
	in a pool once, leading to $F_r * F_c - 1$ comparisons for each of $M_c$
	pools. However, we know that a solution based on sequential merge sort can
	yield a maximum in $O(N \log_2(N))$ comparisons.
	\newline

	Suppose that we find a pool's maximum by comparing each of $F_r$
	items in a given column. Then we can compare each column maximum across
	$F_r$ rows to find the pool maximum. In this case we are dividing into
	three columns, "sorting" out the maximum, and then merging across columns.
	This also offers us an advantage for the given kernel size, namely that one
	column's maximum can be reused where strides overlap.
	If we store the maximum for this column between pools we can
	eliminate the two comparisons that would otherwise be repeated, cutting our
	comparisons per pool down to $6$ for the non-edge pools. This is visualized
	as follows, with \textbf{dashed lines} indicating comparisons between column
	maximums.
	\newline


	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[scale=1.0, thick]
			\settoggle{colortoggle}{false}
			\foreach \l [count=\i] in {0, ..., 1} {
				\iftoggle{colortoggle}{
					\def \loopcolor {blue}
				}{
					\def \loopcolor {red}
				}
				\global\settoggle{colortoggle}{\iftoggle{colortoggle}{false}{true}}
				\pgfmathsetmacro{\j}{2 * \l}
				\draw[grid, pool, color=\loopcolor] (\j, 0) grid (\j+3, 3);
				\global\let\j=\j
			}

			\foreach \l in {0, ..., 2} {
				\foreach \j [count=\i] in {0, ..., 1} {
					\draw[bound, color=red] ({\l+\i*0.33}, \j+0.5) --
						({\l+\i*0.33}, \j+1.5);
				}
				\ifnumcomp{\l}{<}{2} {
					\draw[bound, color=red, dashed] ({\l+0.6, 0.25}) --
						({\l+1.4}, 0.25);
				}{}
			}
			\foreach \l in {3, ..., 4} {
				\foreach \j [count=\i] in {0, ..., 1} {
					\draw[bound, color=blue] ({\l+\i*0.33}, \j+0.5) --
						({\l+\i*0.33}, \j+1.5);
				}
				\ifnumcomp{\l}{<}{5} {
					\draw[bound, color=blue, dashed] ({\l-0.4, 0.25}) --
						({\l+0.4}, 0.25);
				}{}
			}
		\end{tikzpicture}
	\end{figure}

	So we know that we will have $8$ comparisons for one of the edge pools,
	and $6$ comparisons for each of the $M_c - 1$ pools.

	\begin{align}
		\text{Comparisons} &= 8 + (M_c - 1)*6 \\
		&= 8 + (n - 1)*6 \\
		&= 8 + 6n - 6 \\
		&= 6n + 2 \\
	\end{align}

	From the above picture we can count $10+4=14$ comparisons for the case
	$2n+1=5$. So for $n=2$ we will have $12+2=14$ comparisons. Note that this
	result of $6n+2$ comparisons represents a significant savings over the $8n$
	comparisons in the naive case. Also note that for a larger kernel size the
	algorithm would resemble mergesort with logarithmic comparison asymptotes
	across filter rows and columns. We would potentially lose the overlap
	between strides for other kernel sizes and strides.


\end{proof}

% =========================================================
\HomeworkHeader{5 (Algorithms)}{3}% homework number, problem number
% ---------------------------------------------------------
\begin{solution}
	$m(6n+2), n > m$
\end{solution}


\begin{proof}
	We can infer $M_r$ from the result of the previous problem.
	The pooling operation can be visualized as

	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[scale=0.5, thick]
			\draw[grid] (3,-5) grid (7,-7);
			\settoggle{colortoggle}{false}
			\foreach \l [count=\i] in {0, ..., 3} {
				\iftoggle{colortoggle}{
					\def \loopcolor {blue}
				}{
					\def \loopcolor {red}
				}
				\global\settoggle{colortoggle}{\iftoggle{colortoggle}{false}{true}}
				\pgfmathsetmacro{\j}{2 * \l}
				\draw[grid, pool, color=\loopcolor] (\j, 0) grid (\j+3, 3);
				\draw[bound, color=\loopcolor] (\j, 0) -- (\j+3, 3);
				\draw[bound, color=\loopcolor] (\j, 3) -- (\j+3, 0);
				\draw[edge, color=\loopcolor] (\j+1.5, 1.5) -- (\i+2.5, -5);
				\global\let\j=\j
			}
			\foreach \l [count=\i] in {0, ..., 3} {
				\iftoggle{colortoggle}{
					\def \loopcolor {green}
				}{
					\def \loopcolor {purple}
				}
				\global\settoggle{colortoggle}{\iftoggle{colortoggle}{false}{true}}
				\pgfmathsetmacro{\j}{2 * \l}
				\draw[grid, pool, color=\loopcolor] (\j, 2) grid (\j+3, 5);
				\draw[bound, color=\loopcolor, dashed] (\j, 2) -- (\j+3, 5);
				\draw[bound, color=\loopcolor, dashed] (\j, 5) -- (\j+3, 2);
				\draw[edge, color=\loopcolor, dashed] (\j+1.5, 3.5) -- (\i+2.5, -6);
				\global\let\j=\j
			}
		\end{tikzpicture}
		\caption{Ugly picture of the pooling operation for non-trivial rows}
	\end{figure}

	From this unpleasant picture we can see that the construction from the
	trivial row case is still viable, however we would see no savings from the
	overlapping of row maximums. Our comparisons would be as follows, again
	with \textbf{dashed} lines representing comparisons between maximums


	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[scale=1.0, thick]
			\settoggle{colortoggle}{false}
			\foreach \l [count=\i] in {0, ..., 1} {
				\iftoggle{colortoggle}{
					\def \loopcolor {blue}
				}{
					\def \loopcolor {red}
				}
				\global\settoggle{colortoggle}{\iftoggle{colortoggle}{false}{true}}
				\pgfmathsetmacro{\j}{2 * \l}
				\draw[grid, pool, color=\loopcolor] (\j, 0) grid (\j+3, 3);
				\global\let\j=\j
			}
			\foreach \l [count=\i] in {0, ..., 1} {
				\iftoggle{colortoggle}{
					\def \loopcolor {green}
				}{
					\def \loopcolor {black}
				}
				\global\settoggle{colortoggle}{\iftoggle{colortoggle}{false}{true}}
				\pgfmathsetmacro{\j}{2 * \l}
				\draw[grid, pool, color=\loopcolor] (\j, 2) grid (\j+3, 5);
				\global\let\j=\j
			}

			\foreach \l in {0, ..., 2} {
				\foreach \j [count=\i] in {0, ..., 1} {
					\draw[bound, color=red] ({\l+\i*0.33}, \j+0.5) --
						({\l+\i*0.33}, \j+1.5);
				}
				\ifnumcomp{\l}{<}{2} {
					\draw[bound, color=red, dashed] ({\l+0.6, 0.25}) --
						({\l+1.4}, 0.25);
				}{}
			}
			\foreach \l in {3, ..., 4} {
				\foreach \j [count=\i] in {0, ..., 1} {
					\draw[bound, color=blue] ({\l+\i*0.33}, \j+0.5) --
						({\l+\i*0.33}, \j+1.5);
				}
				\ifnumcomp{\l}{<}{5} {
					\draw[bound, color=blue, dashed] ({\l-0.4, 0.25}) --
						({\l+0.4}, 0.25);
				}{}
			}
			\foreach \l in {0, ..., 2} {
				\foreach \j [count=\i] in {2, ..., 3} {
					\draw[bound, color=black] ({\l+\i*0.33}, \j+0.5) --
						({\l+\i*0.33}, \j+1.5);
				}
				\ifnumcomp{\l}{<}{2} {
					\draw[bound, color=black, dashed] ({\l+0.7, 2.25}) --
						({\l+1.4}, 2.25);
				}{}
			}
			\foreach \l in {3, ..., 4} {
				\foreach \j [count=\i] in {2, ..., 3} {
					\draw[bound, color=green] ({\l+\i*0.33}, \j+0.5) --
						({\l+\i*0.33}, \j+1.5);
				}
				\ifnumcomp{\l}{<}{5} {
					\draw[bound, color=green, dashed] ({\l-0.3, 2.25}) --
						({\l+0.4}, 2.25);
				}{}
			}
		\end{tikzpicture}
	\end{figure}

	In this case, our minimum number of
	comparisons is achieved by exploiting the stride overlap along the longer
	of $m, n$ yielding the result

	\begin{align}
		\text{Comparisons} &= m \cdot (6n+2) & n &> m
	\end{align}
\end{proof}

\end{document}
